// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

use dbus;
use dbus::arg;
use dbus::tree;

pub trait OrgFreedesktopDBusPeer {
    fn ping(&self) -> Result<(), tree::MethodErr>;
    fn get_machine_id(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_freedesktop_dbus_peer_server<F, T, D>(
    factory: &tree::Factory<tree::MTFn<D>, D>,
    data: D::Interface,
    f: F,
) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusPeer,
    F: 'static + for<'z> Fn(&'z tree::MethodInfo<tree::MTFn<D>, D>) -> &'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Peer", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.ping()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Ping", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let machine_uuid = d.get_machine_id()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(machine_uuid);
        Ok(vec![rm])
    };
    let m = factory.method("GetMachineId", Default::default(), h);
    let m = m.out_arg(("machine_uuid", "s"));
    let i = i.add_m(m);
    i
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_freedesktop_dbus_introspectable_server<F, T, D>(
    factory: &tree::Factory<tree::MTFn<D>, D>,
    data: D::Interface,
    f: F,
) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusIntrospectable,
    F: 'static + for<'z> Fn(&'z tree::MethodInfo<tree::MTFn<D>, D>) -> &'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Introspectable", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let data = d.introspect()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(data);
        Ok(vec![rm])
    };
    let m = factory.method("Introspect", Default::default(), h);
    let m = m.out_arg(("data", "s"));
    let i = i.add_m(m);
    i
}

pub trait OrgFreedesktopDBusProperties {
    fn get(
        &self,
        interface: &str,
        property: &str,
    ) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, tree::MethodErr>;
    fn get_all(
        &self,
        interface: &str,
    ) -> Result<
        ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
        tree::MethodErr,
    >;
    fn set(
        &self,
        interface: &str,
        property: &str,
        value: arg::Variant<Box<dyn arg::RefArg>>,
    ) -> Result<(), tree::MethodErr>;
}

pub fn org_freedesktop_dbus_properties_server<F, T, D>(
    factory: &tree::Factory<tree::MTFn<D>, D>,
    data: D::Interface,
    f: F,
) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Signal: Default,
    T: OrgFreedesktopDBusProperties,
    F: 'static + for<'z> Fn(&'z tree::MethodInfo<tree::MTFn<D>, D>) -> &'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Properties", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let property: &str = i.read()?;
        let d = fclone(minfo);
        let value = d.get(interface, property)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(value);
        Ok(vec![rm])
    };
    let m = factory.method("Get", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.in_arg(("property", "s"));
    let m = m.out_arg(("value", "v"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let d = fclone(minfo);
        let properties = d.get_all(interface)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(properties);
        Ok(vec![rm])
    };
    let m = factory.method("GetAll", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.out_arg(("properties", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let property: &str = i.read()?;
        let value: arg::Variant<Box<dyn arg::RefArg>> = i.read()?;
        let d = fclone(minfo);
        d.set(interface, property, value)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Set", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.in_arg(("property", "s"));
    let m = m.in_arg(("value", "v"));
    let i = i.add_m(m);
    let s = factory.signal("PropertiesChanged", Default::default());
    let s = s.arg(("interface", "s"));
    let s = s.arg(("changed_properties", "a{sv}"));
    let s = s.arg(("invalidated_properties", "as"));
    let i = i.add_s(s);
    i
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface: String,
    pub changed_properties:
        ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

pub trait OrgFreedesktopSystemd1Manager {
    fn get_unit(&self, arg0: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn get_unit_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn get_unit_by_invocation_id(
        &self,
        arg0: Vec<u8>,
    ) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn get_unit_by_control_group(&self, arg0: &str)
        -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn load_unit(&self, arg0: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn start_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn start_unit_replace(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: &str,
    ) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn stop_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn reload_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn try_restart_unit(
        &self,
        arg0: &str,
        arg1: &str,
    ) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn reload_or_restart_unit(
        &self,
        arg0: &str,
        arg1: &str,
    ) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn reload_or_try_restart_unit(
        &self,
        arg0: &str,
        arg1: &str,
    ) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn enqueue_unit_job(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: &str,
    ) -> Result<
        (
            u32,
            dbus::Path<'static>,
            String,
            dbus::Path<'static>,
            String,
            Vec<(
                u32,
                dbus::Path<'static>,
                String,
                dbus::Path<'static>,
                String,
            )>,
        ),
        tree::MethodErr,
    >;
    fn kill_unit(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), tree::MethodErr>;
    fn clean_unit(&self, arg0: &str, arg1: Vec<&str>) -> Result<(), tree::MethodErr>;
    fn reset_failed_unit(&self, arg0: &str) -> Result<(), tree::MethodErr>;
    fn set_unit_properties(
        &self,
        arg0: &str,
        arg1: bool,
        arg2: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>,
    ) -> Result<(), tree::MethodErr>;
    fn ref_unit(&self, arg0: &str) -> Result<(), tree::MethodErr>;
    fn unref_unit(&self, arg0: &str) -> Result<(), tree::MethodErr>;
    fn start_transient_unit(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>,
        arg3: Vec<(&str, Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>)>,
    ) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn get_unit_processes(&self, arg0: &str)
        -> Result<Vec<(String, u32, String)>, tree::MethodErr>;
    fn attach_processes_to_unit(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: Vec<u32>,
    ) -> Result<(), tree::MethodErr>;
    fn abandon_scope(&self, arg0: &str) -> Result<(), tree::MethodErr>;
    fn get_job(&self, arg0: u32) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn get_job_after(
        &self,
        arg0: u32,
    ) -> Result<
        Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )>,
        tree::MethodErr,
    >;
    fn get_job_before(
        &self,
        arg0: u32,
    ) -> Result<
        Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )>,
        tree::MethodErr,
    >;
    fn cancel_job(&self, arg0: u32) -> Result<(), tree::MethodErr>;
    fn clear_jobs(&self) -> Result<(), tree::MethodErr>;
    fn reset_failed(&self) -> Result<(), tree::MethodErr>;
    fn list_units(
        &self,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        tree::MethodErr,
    >;
    fn list_units_filtered(
        &self,
        arg0: Vec<&str>,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        tree::MethodErr,
    >;
    fn list_units_by_patterns(
        &self,
        arg0: Vec<&str>,
        arg1: Vec<&str>,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        tree::MethodErr,
    >;
    fn list_units_by_names(
        &self,
        arg0: Vec<&str>,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        tree::MethodErr,
    >;
    fn list_jobs(
        &self,
    ) -> Result<
        Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )>,
        tree::MethodErr,
    >;
    fn subscribe(&self) -> Result<(), tree::MethodErr>;
    fn unsubscribe(&self) -> Result<(), tree::MethodErr>;
    fn dump(&self) -> Result<String, tree::MethodErr>;
    fn dump_by_file_descriptor(&self) -> Result<dbus::arg::OwnedFd, tree::MethodErr>;
    fn reload(&self) -> Result<(), tree::MethodErr>;
    fn reexecute(&self) -> Result<(), tree::MethodErr>;
    fn exit(&self) -> Result<(), tree::MethodErr>;
    fn reboot(&self) -> Result<(), tree::MethodErr>;
    fn power_off(&self) -> Result<(), tree::MethodErr>;
    fn halt(&self) -> Result<(), tree::MethodErr>;
    fn kexec(&self) -> Result<(), tree::MethodErr>;
    fn switch_root(&self, arg0: &str, arg1: &str) -> Result<(), tree::MethodErr>;
    fn set_environment(&self, arg0: Vec<&str>) -> Result<(), tree::MethodErr>;
    fn unset_environment(&self, arg0: Vec<&str>) -> Result<(), tree::MethodErr>;
    fn unset_and_set_environment(
        &self,
        arg0: Vec<&str>,
        arg1: Vec<&str>,
    ) -> Result<(), tree::MethodErr>;
    fn list_unit_files(&self) -> Result<Vec<(String, String)>, tree::MethodErr>;
    fn list_unit_files_by_patterns(
        &self,
        arg0: Vec<&str>,
        arg1: Vec<&str>,
    ) -> Result<Vec<(String, String)>, tree::MethodErr>;
    fn get_unit_file_state(&self, arg0: &str) -> Result<String, tree::MethodErr>;
    fn enable_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), tree::MethodErr>;
    fn disable_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
    ) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn reenable_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), tree::MethodErr>;
    fn link_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn preset_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), tree::MethodErr>;
    fn preset_unit_files_with_mode(
        &self,
        arg0: Vec<&str>,
        arg1: &str,
        arg2: bool,
        arg3: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), tree::MethodErr>;
    fn mask_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn unmask_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
    ) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn revert_unit_files(
        &self,
        arg0: Vec<&str>,
    ) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn set_default_target(
        &self,
        arg0: &str,
        arg1: bool,
    ) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn get_default_target(&self) -> Result<String, tree::MethodErr>;
    fn preset_all_unit_files(
        &self,
        arg0: &str,
        arg1: bool,
        arg2: bool,
    ) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn add_dependency_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: &str,
        arg2: &str,
        arg3: bool,
        arg4: bool,
    ) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn get_unit_file_links(&self, arg0: &str, arg1: bool) -> Result<Vec<String>, tree::MethodErr>;
    fn set_exit_code(&self, arg0: u8) -> Result<(), tree::MethodErr>;
    fn lookup_dynamic_user_by_name(&self, arg0: &str) -> Result<u32, tree::MethodErr>;
    fn lookup_dynamic_user_by_uid(&self, arg0: u32) -> Result<String, tree::MethodErr>;
    fn get_dynamic_users(&self) -> Result<Vec<(u32, String)>, tree::MethodErr>;
    fn get_version(&self) -> Result<String, tree::MethodErr>;
    fn get_features(&self) -> Result<String, tree::MethodErr>;
    fn get_virtualization(&self) -> Result<String, tree::MethodErr>;
    fn get_architecture(&self) -> Result<String, tree::MethodErr>;
    fn get_tainted(&self) -> Result<String, tree::MethodErr>;
    fn get_firmware_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_firmware_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_loader_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_loader_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_kernel_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_kernel_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdtimestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdtimestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_userspace_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_userspace_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_security_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_security_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_security_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_security_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_generators_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_generators_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_generators_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_generators_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_units_load_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_units_load_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_units_load_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_units_load_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdsecurity_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdsecurity_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdsecurity_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdsecurity_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdgenerators_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdgenerators_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdgenerators_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdgenerators_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdunits_load_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdunits_load_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdunits_load_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn get_init_rdunits_load_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn get_log_level(&self) -> Result<String, tree::MethodErr>;
    fn set_log_level(&self, value: String) -> Result<(), tree::MethodErr>;
    fn get_log_target(&self) -> Result<String, tree::MethodErr>;
    fn set_log_target(&self, value: String) -> Result<(), tree::MethodErr>;
    fn get_nnames(&self) -> Result<u32, tree::MethodErr>;
    fn get_nfailed_units(&self) -> Result<u32, tree::MethodErr>;
    fn get_njobs(&self) -> Result<u32, tree::MethodErr>;
    fn get_ninstalled_jobs(&self) -> Result<u32, tree::MethodErr>;
    fn get_nfailed_jobs(&self) -> Result<u32, tree::MethodErr>;
    fn get_progress(&self) -> Result<f64, tree::MethodErr>;
    fn get_environment(&self) -> Result<Vec<String>, tree::MethodErr>;
    fn get_confirm_spawn(&self) -> Result<bool, tree::MethodErr>;
    fn get_show_status(&self) -> Result<bool, tree::MethodErr>;
    fn get_unit_path(&self) -> Result<Vec<String>, tree::MethodErr>;
    fn get_default_standard_output(&self) -> Result<String, tree::MethodErr>;
    fn get_default_standard_error(&self) -> Result<String, tree::MethodErr>;
    fn get_runtime_watchdog_usec(&self) -> Result<u64, tree::MethodErr>;
    fn set_runtime_watchdog_usec(&self, value: u64) -> Result<(), tree::MethodErr>;
    fn get_reboot_watchdog_usec(&self) -> Result<u64, tree::MethodErr>;
    fn set_reboot_watchdog_usec(&self, value: u64) -> Result<(), tree::MethodErr>;
    fn get_kexec_watchdog_usec(&self) -> Result<u64, tree::MethodErr>;
    fn set_kexec_watchdog_usec(&self, value: u64) -> Result<(), tree::MethodErr>;
    fn get_service_watchdogs(&self) -> Result<bool, tree::MethodErr>;
    fn set_service_watchdogs(&self, value: bool) -> Result<(), tree::MethodErr>;
    fn get_control_group(&self) -> Result<String, tree::MethodErr>;
    fn get_system_state(&self) -> Result<String, tree::MethodErr>;
    fn get_exit_code(&self) -> Result<u8, tree::MethodErr>;
    fn get_default_timer_accuracy_usec(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_timeout_start_usec(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_timeout_stop_usec(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_timeout_abort_usec(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_restart_usec(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_start_limit_interval_usec(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_start_limit_burst(&self) -> Result<u32, tree::MethodErr>;
    fn get_default_cpuaccounting(&self) -> Result<bool, tree::MethodErr>;
    fn get_default_block_ioaccounting(&self) -> Result<bool, tree::MethodErr>;
    fn get_default_memory_accounting(&self) -> Result<bool, tree::MethodErr>;
    fn get_default_tasks_accounting(&self) -> Result<bool, tree::MethodErr>;
    fn get_default_limit_cpu(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_cpusoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_fsize(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_fsizesoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_data(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_datasoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_stack(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_stacksoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_core(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_coresoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_rss(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_rsssoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_nofile(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_nofilesoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_as(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_assoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_nproc(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_nprocsoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_memlock(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_memlocksoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_locks(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_lockssoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_sigpending(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_sigpendingsoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_msgqueue(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_msgqueuesoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_nice(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_nicesoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_rtprio(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_rtpriosoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_rttime(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_limit_rttimesoft(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_tasks_max(&self) -> Result<u64, tree::MethodErr>;
    fn get_timer_slack_nsec(&self) -> Result<u64, tree::MethodErr>;
    fn get_default_oompolicy(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_freedesktop_systemd1_manager_server<F, T, D>(
    factory: &tree::Factory<tree::MTFn<D>, D>,
    data: D::Interface,
    f: F,
) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    D::Signal: Default,
    T: OrgFreedesktopSystemd1Manager,
    F: 'static + for<'z> Fn(&'z tree::MethodInfo<tree::MTFn<D>, D>) -> &'z T,
{
    let i = factory.interface("org.freedesktop.systemd1.Manager", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_by_pid(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitByPID", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<u8> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_by_invocation_id(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitByInvocationID", Default::default(), h);
    let m = m.in_arg(("", "ay"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_by_control_group(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitByControlGroup", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.load_unit(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("LoadUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.start_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("StartUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.start_unit_replace(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("StartUnitReplace", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.stop_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("StopUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.reload_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ReloadUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.restart_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("RestartUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.try_restart_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("TryRestartUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.reload_or_restart_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ReloadOrRestartUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.reload_or_try_restart_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ReloadOrTryRestartUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: &str = i.read()?;
        let d = fclone(minfo);
        let (arg0, arg1, arg2, arg3, arg4, arg5) = d.enqueue_unit_job(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(arg1);
        let rm = rm.append1(arg2);
        let rm = rm.append1(arg3);
        let rm = rm.append1(arg4);
        let rm = rm.append1(arg5);
        Ok(vec![rm])
    };
    let m = factory.method("EnqueueUnitJob", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "u"));
    let m = m.out_arg(("", "o"));
    let m = m.out_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let m = m.out_arg(("", "s"));
    let m = m.out_arg(("", "a(uosos)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: i32 = i.read()?;
        let d = fclone(minfo);
        d.kill_unit(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("KillUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.clean_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("CleanUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.reset_failed_unit(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("ResetFailedUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)> = i.read()?;
        let d = fclone(minfo);
        d.set_unit_properties(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("SetUnitProperties", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "a(sv)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.ref_unit(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("RefUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.unref_unit(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("UnrefUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)> = i.read()?;
        let arg3: Vec<(&str, Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>)> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.start_transient_unit(arg0, arg1, arg2, arg3)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("StartTransientUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "a(sv)"));
    let m = m.in_arg(("", "a(sa(sv))"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_processes(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitProcesses", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "a(sus)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: Vec<u32> = i.read()?;
        let d = fclone(minfo);
        d.attach_processes_to_unit(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("AttachProcessesToUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "au"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.abandon_scope(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("AbandonScope", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_job(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetJob", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_job_after(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetJobAfter", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "a(usssoo)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_job_before(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetJobBefore", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "a(usssoo)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        d.cancel_job(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("CancelJob", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.clear_jobs()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("ClearJobs", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reset_failed()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("ResetFailed", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.list_units()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnits", Default::default(), h);
    let m = m.out_arg(("", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.list_units_filtered(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnitsFiltered", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.out_arg(("", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.list_units_by_patterns(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnitsByPatterns", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "as"));
    let m = m.out_arg(("", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.list_units_by_names(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnitsByNames", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.out_arg(("", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.list_jobs()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListJobs", Default::default(), h);
    let m = m.out_arg(("", "a(usssoo)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.subscribe()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Subscribe", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.unsubscribe()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Unsubscribe", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.dump()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("Dump", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.dump_by_file_descriptor()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("DumpByFileDescriptor", Default::default(), h);
    let m = m.out_arg(("", "h"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reload()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Reload", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reexecute()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Reexecute", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.exit()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Exit", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reboot()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Reboot", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.power_off()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("PowerOff", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.halt()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Halt", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.kexec()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("KExec", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        d.switch_root(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("SwitchRoot", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.set_environment(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("SetEnvironment", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.unset_environment(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("UnsetEnvironment", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.unset_and_set_environment(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("UnsetAndSetEnvironment", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.list_unit_files()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnitFiles", Default::default(), h);
    let m = m.out_arg(("", "a(ss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.list_unit_files_by_patterns(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnitFilesByPatterns", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "as"));
    let m = m.out_arg(("", "a(ss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_file_state(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitFileState", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let (arg0, arg1) = d.enable_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(arg1);
        Ok(vec![rm])
    };
    let m = factory.method("EnableUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.disable_unit_files(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("DisableUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let (arg0, arg1) = d.reenable_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(arg1);
        Ok(vec![rm])
    };
    let m = factory.method("ReenableUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.link_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("LinkUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let (arg0, arg1) = d.preset_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(arg1);
        Ok(vec![rm])
    };
    let m = factory.method("PresetUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: bool = i.read()?;
        let arg3: bool = i.read()?;
        let d = fclone(minfo);
        let (arg0, arg1) = d.preset_unit_files_with_mode(arg0, arg1, arg2, arg3)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(arg1);
        Ok(vec![rm])
    };
    let m = factory.method("PresetUnitFilesWithMode", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.mask_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("MaskUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.unmask_unit_files(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("UnmaskUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.revert_unit_files(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("RevertUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.set_default_target(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("SetDefaultTarget", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_default_target()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetDefaultTarget", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.preset_all_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("PresetAllUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: &str = i.read()?;
        let arg3: bool = i.read()?;
        let arg4: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.add_dependency_unit_files(arg0, arg1, arg2, arg3, arg4)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("AddDependencyUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_file_links(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitFileLinks", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u8 = i.read()?;
        let d = fclone(minfo);
        d.set_exit_code(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("SetExitCode", Default::default(), h);
    let m = m.in_arg(("", "y"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.lookup_dynamic_user_by_name(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("LookupDynamicUserByName", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.lookup_dynamic_user_by_uid(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("LookupDynamicUserByUID", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_dynamic_users()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetDynamicUsers", Default::default(), h);
    let m = m.out_arg(("", "a(us)"));
    let i = i.add_m(m);

    let p = factory.property::<&str, _>("Version", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_version()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Features", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_features()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Virtualization", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_virtualization()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Architecture", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_architecture()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Tainted", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_tainted()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FirmwareTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_firmware_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FirmwareTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_firmware_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("LoaderTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_loader_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("LoaderTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_loader_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("KernelTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_kernel_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("KernelTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_kernel_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdtimestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdtimestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UserspaceTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_userspace_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UserspaceTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_userspace_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_security_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_security_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_security_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_security_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_generators_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_generators_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_generators_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_generators_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_units_load_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_units_load_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_units_load_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_units_load_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDSecurityStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdsecurity_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDSecurityStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdsecurity_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDSecurityFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdsecurity_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p =
        factory.property::<u64, _>("InitRDSecurityFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdsecurity_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDGeneratorsStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdgenerators_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>(
        "InitRDGeneratorsStartTimestampMonotonic",
        Default::default(),
    );
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdgenerators_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDGeneratorsFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdgenerators_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>(
        "InitRDGeneratorsFinishTimestampMonotonic",
        Default::default(),
    );
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdgenerators_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDUnitsLoadStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdunits_load_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p =
        factory.property::<u64, _>("InitRDUnitsLoadStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdunits_load_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDUnitsLoadFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdunits_load_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>(
        "InitRDUnitsLoadFinishTimestampMonotonic",
        Default::default(),
    );
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdunits_load_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("LogLevel", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_log_level()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_log_level(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("LogTarget", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_log_target()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_log_target(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NNames", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_nnames()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NFailedUnits", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_nfailed_units()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NJobs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_njobs()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NInstalledJobs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_ninstalled_jobs()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NFailedJobs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_nfailed_jobs()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<f64, _>("Progress", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_progress()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("Environment", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_environment()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ConfirmSpawn", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_confirm_spawn()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ShowStatus", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_show_status()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("UnitPath", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_unit_path()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("DefaultStandardOutput", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_standard_output()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("DefaultStandardError", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_standard_error()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("RuntimeWatchdogUSec", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_runtime_watchdog_usec()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_runtime_watchdog_usec(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("RebootWatchdogUSec", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_reboot_watchdog_usec()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_reboot_watchdog_usec(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("KExecWatchdogUSec", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_kexec_watchdog_usec()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_kexec_watchdog_usec(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ServiceWatchdogs", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_service_watchdogs()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_service_watchdogs(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("ControlGroup", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_control_group()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("SystemState", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_system_state()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u8, _>("ExitCode", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_exit_code()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimerAccuracyUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_timer_accuracy_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimeoutStartUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_timeout_start_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimeoutStopUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_timeout_stop_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimeoutAbortUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_timeout_abort_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultRestartUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_restart_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultStartLimitIntervalUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_start_limit_interval_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("DefaultStartLimitBurst", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_start_limit_burst()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultCPUAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_cpuaccounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultBlockIOAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_block_ioaccounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultMemoryAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_memory_accounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultTasksAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_tasks_accounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCPU", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_cpu()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCPUSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_cpusoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitFSIZE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_fsize()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitFSIZESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_fsizesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitDATA", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_data()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitDATASoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_datasoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSTACK", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_stack()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSTACKSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_stacksoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCORE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_core()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCORESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_coresoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRSS", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rss()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRSSSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rsssoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNOFILE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nofile()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNOFILESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nofilesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitAS", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_as()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitASSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_assoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNPROC", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nproc()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNPROCSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nprocsoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMEMLOCK", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_memlock()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMEMLOCKSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_memlocksoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitLOCKS", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_locks()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitLOCKSSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_lockssoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSIGPENDING", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_sigpending()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSIGPENDINGSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_sigpendingsoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMSGQUEUE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_msgqueue()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMSGQUEUESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_msgqueuesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNICE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nice()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNICESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nicesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTPRIO", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rtprio()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTPRIOSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rtpriosoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTTIME", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rttime()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTTIMESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rttimesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTasksMax", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_tasks_max()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("TimerSlackNSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_timer_slack_nsec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("DefaultOOMPolicy", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_oompolicy()?);
        Ok(())
    });
    let i = i.add_p(p);
    let s = factory.signal("UnitNew", Default::default());
    let s = s.arg(("", "s"));
    let s = s.arg(("", "o"));
    let i = i.add_s(s);
    let s = factory.signal("UnitRemoved", Default::default());
    let s = s.arg(("", "s"));
    let s = s.arg(("", "o"));
    let i = i.add_s(s);
    let s = factory.signal("JobNew", Default::default());
    let s = s.arg(("", "u"));
    let s = s.arg(("", "o"));
    let s = s.arg(("", "s"));
    let i = i.add_s(s);
    let s = factory.signal("JobRemoved", Default::default());
    let s = s.arg(("", "u"));
    let s = s.arg(("", "o"));
    let s = s.arg(("", "s"));
    let s = s.arg(("", "s"));
    let i = i.add_s(s);
    let s = factory.signal("StartupFinished", Default::default());
    let s = s.arg(("", "t"));
    let s = s.arg(("", "t"));
    let s = s.arg(("", "t"));
    let s = s.arg(("", "t"));
    let s = s.arg(("", "t"));
    let s = s.arg(("", "t"));
    let i = i.add_s(s);
    let s = factory.signal("UnitFilesChanged", Default::default());
    let i = i.add_s(s);
    let s = factory.signal("Reloading", Default::default());
    let s = s.arg(("", "b"));
    let i = i.add_s(s);
    i
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerUnitNew {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerUnitNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerUnitNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerUnitNew {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerUnitNew {
    const NAME: &'static str = "UnitNew";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerUnitRemoved {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerUnitRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerUnitRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerUnitRemoved {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerUnitRemoved {
    const NAME: &'static str = "UnitRemoved";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerJobNew {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
    pub arg2: String,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerJobNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
        arg::RefArg::append(&self.arg2, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerJobNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerJobNew {
            arg0: i.read()?,
            arg1: i.read()?,
            arg2: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerJobNew {
    const NAME: &'static str = "JobNew";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerJobRemoved {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
    pub arg2: String,
    pub arg3: String,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerJobRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
        arg::RefArg::append(&self.arg2, i);
        arg::RefArg::append(&self.arg3, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerJobRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerJobRemoved {
            arg0: i.read()?,
            arg1: i.read()?,
            arg2: i.read()?,
            arg3: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerJobRemoved {
    const NAME: &'static str = "JobRemoved";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerStartupFinished {
    pub arg0: u64,
    pub arg1: u64,
    pub arg2: u64,
    pub arg3: u64,
    pub arg4: u64,
    pub arg5: u64,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerStartupFinished {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
        arg::RefArg::append(&self.arg2, i);
        arg::RefArg::append(&self.arg3, i);
        arg::RefArg::append(&self.arg4, i);
        arg::RefArg::append(&self.arg5, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerStartupFinished {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerStartupFinished {
            arg0: i.read()?,
            arg1: i.read()?,
            arg2: i.read()?,
            arg3: i.read()?,
            arg4: i.read()?,
            arg5: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerStartupFinished {
    const NAME: &'static str = "StartupFinished";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerUnitFilesChanged {}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerUnitFilesChanged {
    fn append(&self, _: &mut arg::IterAppend) {}
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerUnitFilesChanged {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerUnitFilesChanged {})
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerUnitFilesChanged {
    const NAME: &'static str = "UnitFilesChanged";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerReloading {
    pub arg0: bool,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerReloading {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerReloading {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerReloading { arg0: i.read()? })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerReloading {
    const NAME: &'static str = "Reloading";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}
