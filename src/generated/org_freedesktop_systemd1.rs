// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

#![allow(dead_code)]
use dbus;
use dbus::arg;
use dbus::tree;

pub trait OrgFreedesktopDBusPeer {
    type Err;
    fn ping(&self) -> Result<(), Self::Err>;
    fn get_machine_id(&self) -> Result<String, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target = dbus::Connection>> OrgFreedesktopDBusPeer
    for dbus::ConnPath<'a, C>
{
    type Err = dbus::Error;

    fn ping(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.DBus.Peer".into(),
            &"Ping".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn get_machine_id(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.DBus.Peer".into(),
            &"GetMachineId".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let machine_uuid: String = i.read()?;
        Ok(machine_uuid)
    }
}

pub fn org_freedesktop_dbus_peer_server<F, T, D>(
    factory: &tree::Factory<tree::MTFn<D>, D>,
    data: D::Interface,
    f: F,
) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusPeer<Err = tree::MethodErr>,
    F: 'static + for<'z> Fn(&'z tree::MethodInfo<tree::MTFn<D>, D>) -> &'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Peer", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.ping()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Ping", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let machine_uuid = d.get_machine_id()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(machine_uuid);
        Ok(vec![rm])
    };
    let m = factory.method("GetMachineId", Default::default(), h);
    let m = m.out_arg(("machine_uuid", "s"));
    let i = i.add_m(m);
    i
}

pub trait OrgFreedesktopDBusIntrospectable {
    type Err;
    fn introspect(&self) -> Result<String, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target = dbus::Connection>> OrgFreedesktopDBusIntrospectable
    for dbus::ConnPath<'a, C>
{
    type Err = dbus::Error;

    fn introspect(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.DBus.Introspectable".into(),
            &"Introspect".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let data: String = i.read()?;
        Ok(data)
    }
}

pub fn org_freedesktop_dbus_introspectable_server<F, T, D>(
    factory: &tree::Factory<tree::MTFn<D>, D>,
    data: D::Interface,
    f: F,
) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusIntrospectable<Err = tree::MethodErr>,
    F: 'static + for<'z> Fn(&'z tree::MethodInfo<tree::MTFn<D>, D>) -> &'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Introspectable", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let data = d.introspect()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(data);
        Ok(vec![rm])
    };
    let m = factory.method("Introspect", Default::default(), h);
    let m = m.out_arg(("data", "s"));
    let i = i.add_m(m);
    i
}

pub trait OrgFreedesktopDBusProperties {
    type Err;
    fn get(
        &self,
        interface: &str,
        property: &str,
    ) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, Self::Err>;
    fn get_all(
        &self,
        interface: &str,
    ) -> Result<
        ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
        Self::Err,
    >;
    fn set(
        &self,
        interface: &str,
        property: &str,
        value: arg::Variant<Box<dyn arg::RefArg>>,
    ) -> Result<(), Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target = dbus::Connection>> OrgFreedesktopDBusProperties
    for dbus::ConnPath<'a, C>
{
    type Err = dbus::Error;

    fn get(
        &self,
        interface: &str,
        property: &str,
    ) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.DBus.Properties".into(),
            &"Get".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(interface);
                i.append(property);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let value: arg::Variant<Box<dyn arg::RefArg + 'static>> = i.read()?;
        Ok(value)
    }

    fn get_all(
        &self,
        interface: &str,
    ) -> Result<
        ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
        Self::Err,
    > {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.DBus.Properties".into(),
            &"GetAll".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(interface);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let properties: ::std::collections::HashMap<
            String,
            arg::Variant<Box<dyn arg::RefArg + 'static>>,
        > = i.read()?;
        Ok(properties)
    }

    fn set(
        &self,
        interface: &str,
        property: &str,
        value: arg::Variant<Box<dyn arg::RefArg>>,
    ) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.DBus.Properties".into(),
            &"Set".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(interface);
                i.append(property);
                i.append(value);
            },
        )?;
        m.as_result()?;
        Ok(())
    }
}

pub fn org_freedesktop_dbus_properties_server<F, T, D>(
    factory: &tree::Factory<tree::MTFn<D>, D>,
    data: D::Interface,
    f: F,
) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Signal: Default,
    T: OrgFreedesktopDBusProperties<Err = tree::MethodErr>,
    F: 'static + for<'z> Fn(&'z tree::MethodInfo<tree::MTFn<D>, D>) -> &'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Properties", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let property: &str = i.read()?;
        let d = fclone(minfo);
        let value = d.get(interface, property)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(value);
        Ok(vec![rm])
    };
    let m = factory.method("Get", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.in_arg(("property", "s"));
    let m = m.out_arg(("value", "v"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let d = fclone(minfo);
        let properties = d.get_all(interface)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(properties);
        Ok(vec![rm])
    };
    let m = factory.method("GetAll", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.out_arg(("properties", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let property: &str = i.read()?;
        let value: arg::Variant<Box<dyn arg::RefArg>> = i.read()?;
        let d = fclone(minfo);
        d.set(interface, property, value)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Set", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.in_arg(("property", "s"));
    let m = m.in_arg(("value", "v"));
    let i = i.add_m(m);
    let s = factory.signal("PropertiesChanged", Default::default());
    let s = s.arg(("interface", "s"));
    let s = s.arg(("changed_properties", "a{sv}"));
    let s = s.arg(("invalidated_properties", "as"));
    let i = i.add_s(s);
    i
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface: String,
    pub changed_properties:
        ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
    pub invalidated_properties: Vec<String>,
}

impl dbus::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.interface = i.read()?;
        self.changed_properties = i.read()?;
        self.invalidated_properties = i.read()?;
        Ok(())
    }
}

pub trait OrgFreedesktopSystemd1Manager {
    type Err;
    fn get_unit(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_unit_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_unit_by_invocation_id(&self, arg0: Vec<u8>) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_unit_by_control_group(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn load_unit(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn start_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn start_unit_replace(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: &str,
    ) -> Result<dbus::Path<'static>, Self::Err>;
    fn stop_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn reload_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn try_restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn reload_or_restart_unit(
        &self,
        arg0: &str,
        arg1: &str,
    ) -> Result<dbus::Path<'static>, Self::Err>;
    fn reload_or_try_restart_unit(
        &self,
        arg0: &str,
        arg1: &str,
    ) -> Result<dbus::Path<'static>, Self::Err>;
    fn enqueue_unit_job(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: &str,
    ) -> Result<
        (
            u32,
            dbus::Path<'static>,
            String,
            dbus::Path<'static>,
            String,
            Vec<(
                u32,
                dbus::Path<'static>,
                String,
                dbus::Path<'static>,
                String,
            )>,
        ),
        Self::Err,
    >;
    fn kill_unit(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), Self::Err>;
    fn clean_unit(&self, arg0: &str, arg1: Vec<&str>) -> Result<(), Self::Err>;
    fn reset_failed_unit(&self, arg0: &str) -> Result<(), Self::Err>;
    fn set_unit_properties(
        &self,
        arg0: &str,
        arg1: bool,
        arg2: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>,
    ) -> Result<(), Self::Err>;
    fn ref_unit(&self, arg0: &str) -> Result<(), Self::Err>;
    fn unref_unit(&self, arg0: &str) -> Result<(), Self::Err>;
    fn start_transient_unit(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>,
        arg3: Vec<(&str, Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>)>,
    ) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_unit_processes(&self, arg0: &str) -> Result<Vec<(String, u32, String)>, Self::Err>;
    fn attach_processes_to_unit(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: Vec<u32>,
    ) -> Result<(), Self::Err>;
    fn abandon_scope(&self, arg0: &str) -> Result<(), Self::Err>;
    fn get_job(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_job_after(
        &self,
        arg0: u32,
    ) -> Result<
        Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )>,
        Self::Err,
    >;
    fn get_job_before(
        &self,
        arg0: u32,
    ) -> Result<
        Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )>,
        Self::Err,
    >;
    fn cancel_job(&self, arg0: u32) -> Result<(), Self::Err>;
    fn clear_jobs(&self) -> Result<(), Self::Err>;
    fn reset_failed(&self) -> Result<(), Self::Err>;
    fn list_units(
        &self,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        Self::Err,
    >;
    fn list_units_filtered(
        &self,
        arg0: Vec<&str>,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        Self::Err,
    >;
    fn list_units_by_patterns(
        &self,
        arg0: Vec<&str>,
        arg1: Vec<&str>,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        Self::Err,
    >;
    fn list_units_by_names(
        &self,
        arg0: Vec<&str>,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        Self::Err,
    >;
    fn list_jobs(
        &self,
    ) -> Result<
        Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )>,
        Self::Err,
    >;
    fn subscribe(&self) -> Result<(), Self::Err>;
    fn unsubscribe(&self) -> Result<(), Self::Err>;
    fn dump(&self) -> Result<String, Self::Err>;
    fn dump_by_file_descriptor(&self) -> Result<dbus::OwnedFd, Self::Err>;
    fn reload(&self) -> Result<(), Self::Err>;
    fn reexecute(&self) -> Result<(), Self::Err>;
    fn exit(&self) -> Result<(), Self::Err>;
    fn reboot(&self) -> Result<(), Self::Err>;
    fn power_off(&self) -> Result<(), Self::Err>;
    fn halt(&self) -> Result<(), Self::Err>;
    fn kexec(&self) -> Result<(), Self::Err>;
    fn switch_root(&self, arg0: &str, arg1: &str) -> Result<(), Self::Err>;
    fn set_environment(&self, arg0: Vec<&str>) -> Result<(), Self::Err>;
    fn unset_environment(&self, arg0: Vec<&str>) -> Result<(), Self::Err>;
    fn unset_and_set_environment(&self, arg0: Vec<&str>, arg1: Vec<&str>) -> Result<(), Self::Err>;
    fn list_unit_files(&self) -> Result<Vec<(String, String)>, Self::Err>;
    fn list_unit_files_by_patterns(
        &self,
        arg0: Vec<&str>,
        arg1: Vec<&str>,
    ) -> Result<Vec<(String, String)>, Self::Err>;
    fn get_unit_file_state(&self, arg0: &str) -> Result<String, Self::Err>;
    fn enable_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), Self::Err>;
    fn disable_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn reenable_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), Self::Err>;
    fn link_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn preset_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), Self::Err>;
    fn preset_unit_files_with_mode(
        &self,
        arg0: Vec<&str>,
        arg1: &str,
        arg2: bool,
        arg3: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), Self::Err>;
    fn mask_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn unmask_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn revert_unit_files(
        &self,
        arg0: Vec<&str>,
    ) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn set_default_target(
        &self,
        arg0: &str,
        arg1: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn get_default_target(&self) -> Result<String, Self::Err>;
    fn preset_all_unit_files(
        &self,
        arg0: &str,
        arg1: bool,
        arg2: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn add_dependency_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: &str,
        arg2: &str,
        arg3: bool,
        arg4: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn get_unit_file_links(&self, arg0: &str, arg1: bool) -> Result<Vec<String>, Self::Err>;
    fn set_exit_code(&self, arg0: u8) -> Result<(), Self::Err>;
    fn lookup_dynamic_user_by_name(&self, arg0: &str) -> Result<u32, Self::Err>;
    fn lookup_dynamic_user_by_uid(&self, arg0: u32) -> Result<String, Self::Err>;
    fn get_dynamic_users(&self) -> Result<Vec<(u32, String)>, Self::Err>;
    fn get_version(&self) -> Result<String, Self::Err>;
    fn get_features(&self) -> Result<String, Self::Err>;
    fn get_virtualization(&self) -> Result<String, Self::Err>;
    fn get_architecture(&self) -> Result<String, Self::Err>;
    fn get_tainted(&self) -> Result<String, Self::Err>;
    fn get_firmware_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_firmware_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_loader_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_loader_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_kernel_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_kernel_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_init_rdtimestamp(&self) -> Result<u64, Self::Err>;
    fn get_init_rdtimestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_userspace_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_userspace_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_finish_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_security_start_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_security_start_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_security_finish_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_security_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_generators_start_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_generators_start_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_generators_finish_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_generators_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_units_load_start_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_units_load_start_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_units_load_finish_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_units_load_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_init_rdsecurity_start_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_init_rdsecurity_start_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_init_rdsecurity_finish_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_init_rdsecurity_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_init_rdgenerators_start_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_init_rdgenerators_start_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_init_rdgenerators_finish_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_init_rdgenerators_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_init_rdunits_load_start_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_init_rdunits_load_start_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_init_rdunits_load_finish_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_init_rdunits_load_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_log_level(&self) -> Result<String, Self::Err>;
    fn set_log_level(&self, value: String) -> Result<(), Self::Err>;
    fn get_log_target(&self) -> Result<String, Self::Err>;
    fn set_log_target(&self, value: String) -> Result<(), Self::Err>;
    fn get_nnames(&self) -> Result<u32, Self::Err>;
    fn get_nfailed_units(&self) -> Result<u32, Self::Err>;
    fn get_njobs(&self) -> Result<u32, Self::Err>;
    fn get_ninstalled_jobs(&self) -> Result<u32, Self::Err>;
    fn get_nfailed_jobs(&self) -> Result<u32, Self::Err>;
    fn get_progress(&self) -> Result<f64, Self::Err>;
    fn get_environment(&self) -> Result<Vec<String>, Self::Err>;
    fn get_confirm_spawn(&self) -> Result<bool, Self::Err>;
    fn get_show_status(&self) -> Result<bool, Self::Err>;
    fn get_unit_path(&self) -> Result<Vec<String>, Self::Err>;
    fn get_default_standard_output(&self) -> Result<String, Self::Err>;
    fn get_default_standard_error(&self) -> Result<String, Self::Err>;
    fn get_runtime_watchdog_usec(&self) -> Result<u64, Self::Err>;
    fn set_runtime_watchdog_usec(&self, value: u64) -> Result<(), Self::Err>;
    fn get_reboot_watchdog_usec(&self) -> Result<u64, Self::Err>;
    fn set_reboot_watchdog_usec(&self, value: u64) -> Result<(), Self::Err>;
    fn get_kexec_watchdog_usec(&self) -> Result<u64, Self::Err>;
    fn set_kexec_watchdog_usec(&self, value: u64) -> Result<(), Self::Err>;
    fn get_service_watchdogs(&self) -> Result<bool, Self::Err>;
    fn set_service_watchdogs(&self, value: bool) -> Result<(), Self::Err>;
    fn get_control_group(&self) -> Result<String, Self::Err>;
    fn get_system_state(&self) -> Result<String, Self::Err>;
    fn get_exit_code(&self) -> Result<u8, Self::Err>;
    fn get_default_timer_accuracy_usec(&self) -> Result<u64, Self::Err>;
    fn get_default_timeout_start_usec(&self) -> Result<u64, Self::Err>;
    fn get_default_timeout_stop_usec(&self) -> Result<u64, Self::Err>;
    fn get_default_timeout_abort_usec(&self) -> Result<u64, Self::Err>;
    fn get_default_restart_usec(&self) -> Result<u64, Self::Err>;
    fn get_default_start_limit_interval_usec(&self) -> Result<u64, Self::Err>;
    fn get_default_start_limit_burst(&self) -> Result<u32, Self::Err>;
    fn get_default_cpuaccounting(&self) -> Result<bool, Self::Err>;
    fn get_default_block_ioaccounting(&self) -> Result<bool, Self::Err>;
    fn get_default_memory_accounting(&self) -> Result<bool, Self::Err>;
    fn get_default_tasks_accounting(&self) -> Result<bool, Self::Err>;
    fn get_default_limit_cpu(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_cpusoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_fsize(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_fsizesoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_data(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_datasoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_stack(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_stacksoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_core(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_coresoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rss(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rsssoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nofile(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nofilesoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_as(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_assoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nproc(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nprocsoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_memlock(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_memlocksoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_locks(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_lockssoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_sigpending(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_sigpendingsoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_msgqueue(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_msgqueuesoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nice(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nicesoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rtprio(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rtpriosoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rttime(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rttimesoft(&self) -> Result<u64, Self::Err>;
    fn get_default_tasks_max(&self) -> Result<u64, Self::Err>;
    fn get_timer_slack_nsec(&self) -> Result<u64, Self::Err>;
    fn get_default_oompolicy(&self) -> Result<String, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target = dbus::Connection>> OrgFreedesktopSystemd1Manager
    for dbus::ConnPath<'a, C>
{
    type Err = dbus::Error;

    fn get_unit(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_unit_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetUnitByPID".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_unit_by_invocation_id(&self, arg0: Vec<u8>) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetUnitByInvocationID".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_unit_by_control_group(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetUnitByControlGroup".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn load_unit(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"LoadUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn start_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"StartUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn start_unit_replace(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: &str,
    ) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"StartUnitReplace".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn stop_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"StopUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn reload_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ReloadUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"RestartUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn try_restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"TryRestartUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn reload_or_restart_unit(
        &self,
        arg0: &str,
        arg1: &str,
    ) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ReloadOrRestartUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn reload_or_try_restart_unit(
        &self,
        arg0: &str,
        arg1: &str,
    ) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ReloadOrTryRestartUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn enqueue_unit_job(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: &str,
    ) -> Result<
        (
            u32,
            dbus::Path<'static>,
            String,
            dbus::Path<'static>,
            String,
            Vec<(
                u32,
                dbus::Path<'static>,
                String,
                dbus::Path<'static>,
                String,
            )>,
        ),
        Self::Err,
    > {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"EnqueueUnitJob".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: u32 = i.read()?;
        let arg1: dbus::Path<'static> = i.read()?;
        let arg2: String = i.read()?;
        let arg3: dbus::Path<'static> = i.read()?;
        let arg4: String = i.read()?;
        let arg5: Vec<(
            u32,
            dbus::Path<'static>,
            String,
            dbus::Path<'static>,
            String,
        )> = i.read()?;
        Ok((arg0, arg1, arg2, arg3, arg4, arg5))
    }

    fn kill_unit(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"KillUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn clean_unit(&self, arg0: &str, arg1: Vec<&str>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"CleanUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn reset_failed_unit(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ResetFailedUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn set_unit_properties(
        &self,
        arg0: &str,
        arg1: bool,
        arg2: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>,
    ) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"SetUnitProperties".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn ref_unit(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"RefUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn unref_unit(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"UnrefUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn start_transient_unit(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>,
        arg3: Vec<(&str, Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>)>,
    ) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"StartTransientUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
                i.append(arg3);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_unit_processes(&self, arg0: &str) -> Result<Vec<(String, u32, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetUnitProcesses".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, u32, String)> = i.read()?;
        Ok(arg0)
    }

    fn attach_processes_to_unit(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: Vec<u32>,
    ) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"AttachProcessesToUnit".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn abandon_scope(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"AbandonScope".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn get_job(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetJob".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_job_after(
        &self,
        arg0: u32,
    ) -> Result<
        Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )>,
        Self::Err,
    > {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetJobAfter".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )> = i.read()?;
        Ok(arg0)
    }

    fn get_job_before(
        &self,
        arg0: u32,
    ) -> Result<
        Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )>,
        Self::Err,
    > {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetJobBefore".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )> = i.read()?;
        Ok(arg0)
    }

    fn cancel_job(&self, arg0: u32) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"CancelJob".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn clear_jobs(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ClearJobs".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn reset_failed(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ResetFailed".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn list_units(
        &self,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        Self::Err,
    > {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ListUnits".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )> = i.read()?;
        Ok(arg0)
    }

    fn list_units_filtered(
        &self,
        arg0: Vec<&str>,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        Self::Err,
    > {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ListUnitsFiltered".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )> = i.read()?;
        Ok(arg0)
    }

    fn list_units_by_patterns(
        &self,
        arg0: Vec<&str>,
        arg1: Vec<&str>,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        Self::Err,
    > {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ListUnitsByPatterns".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )> = i.read()?;
        Ok(arg0)
    }

    fn list_units_by_names(
        &self,
        arg0: Vec<&str>,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )>,
        Self::Err,
    > {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ListUnitsByNames".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(
            String,
            String,
            String,
            String,
            String,
            String,
            dbus::Path<'static>,
            u32,
            String,
            dbus::Path<'static>,
        )> = i.read()?;
        Ok(arg0)
    }

    fn list_jobs(
        &self,
    ) -> Result<
        Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )>,
        Self::Err,
    > {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ListJobs".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(
            u32,
            String,
            String,
            String,
            dbus::Path<'static>,
            dbus::Path<'static>,
        )> = i.read()?;
        Ok(arg0)
    }

    fn subscribe(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"Subscribe".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn unsubscribe(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"Unsubscribe".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn dump(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"Dump".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn dump_by_file_descriptor(&self) -> Result<dbus::OwnedFd, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"DumpByFileDescriptor".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::OwnedFd = i.read()?;
        Ok(arg0)
    }

    fn reload(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"Reload".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn reexecute(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"Reexecute".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn exit(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"Exit".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn reboot(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"Reboot".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn power_off(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"PowerOff".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn halt(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"Halt".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn kexec(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"KExec".into(),
            |_| {},
        )?;
        m.as_result()?;
        Ok(())
    }

    fn switch_root(&self, arg0: &str, arg1: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"SwitchRoot".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn set_environment(&self, arg0: Vec<&str>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"SetEnvironment".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn unset_environment(&self, arg0: Vec<&str>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"UnsetEnvironment".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn unset_and_set_environment(&self, arg0: Vec<&str>, arg1: Vec<&str>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"UnsetAndSetEnvironment".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn list_unit_files(&self) -> Result<Vec<(String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ListUnitFiles".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String)> = i.read()?;
        Ok(arg0)
    }

    fn list_unit_files_by_patterns(
        &self,
        arg0: Vec<&str>,
        arg1: Vec<&str>,
    ) -> Result<Vec<(String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ListUnitFilesByPatterns".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String)> = i.read()?;
        Ok(arg0)
    }

    fn get_unit_file_state(&self, arg0: &str) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetUnitFileState".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn enable_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"EnableUnitFiles".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: bool = i.read()?;
        let arg1: Vec<(String, String, String)> = i.read()?;
        Ok((arg0, arg1))
    }

    fn disable_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"DisableUnitFiles".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn reenable_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"ReenableUnitFiles".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: bool = i.read()?;
        let arg1: Vec<(String, String, String)> = i.read()?;
        Ok((arg0, arg1))
    }

    fn link_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"LinkUnitFiles".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn preset_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"PresetUnitFiles".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: bool = i.read()?;
        let arg1: Vec<(String, String, String)> = i.read()?;
        Ok((arg0, arg1))
    }

    fn preset_unit_files_with_mode(
        &self,
        arg0: Vec<&str>,
        arg1: &str,
        arg2: bool,
        arg3: bool,
    ) -> Result<(bool, Vec<(String, String, String)>), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"PresetUnitFilesWithMode".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
                i.append(arg3);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: bool = i.read()?;
        let arg1: Vec<(String, String, String)> = i.read()?;
        Ok((arg0, arg1))
    }

    fn mask_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
        arg2: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"MaskUnitFiles".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn unmask_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"UnmaskUnitFiles".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn revert_unit_files(
        &self,
        arg0: Vec<&str>,
    ) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"RevertUnitFiles".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn set_default_target(
        &self,
        arg0: &str,
        arg1: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"SetDefaultTarget".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn get_default_target(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetDefaultTarget".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn preset_all_unit_files(
        &self,
        arg0: &str,
        arg1: bool,
        arg2: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"PresetAllUnitFiles".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn add_dependency_unit_files(
        &self,
        arg0: Vec<&str>,
        arg1: &str,
        arg2: &str,
        arg3: bool,
        arg4: bool,
    ) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"AddDependencyUnitFiles".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
                i.append(arg2);
                i.append(arg3);
                i.append(arg4);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn get_unit_file_links(&self, arg0: &str, arg1: bool) -> Result<Vec<String>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetUnitFileLinks".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
                i.append(arg1);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<String> = i.read()?;
        Ok(arg0)
    }

    fn set_exit_code(&self, arg0: u8) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"SetExitCode".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn lookup_dynamic_user_by_name(&self, arg0: &str) -> Result<u32, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"LookupDynamicUserByName".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: u32 = i.read()?;
        Ok(arg0)
    }

    fn lookup_dynamic_user_by_uid(&self, arg0: u32) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"LookupDynamicUserByUID".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn get_dynamic_users(&self) -> Result<Vec<(u32, String)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.systemd1.Manager".into(),
            &"GetDynamicUsers".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(u32, String)> = i.read()?;
        Ok(arg0)
    }

    fn get_version(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "Version",
        )
    }

    fn get_features(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "Features",
        )
    }

    fn get_virtualization(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "Virtualization",
        )
    }

    fn get_architecture(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "Architecture",
        )
    }

    fn get_tainted(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "Tainted",
        )
    }

    fn get_firmware_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "FirmwareTimestamp",
        )
    }

    fn get_firmware_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "FirmwareTimestampMonotonic",
        )
    }

    fn get_loader_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "LoaderTimestamp",
        )
    }

    fn get_loader_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "LoaderTimestampMonotonic",
        )
    }

    fn get_kernel_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "KernelTimestamp",
        )
    }

    fn get_kernel_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "KernelTimestampMonotonic",
        )
    }

    fn get_init_rdtimestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDTimestamp",
        )
    }

    fn get_init_rdtimestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDTimestampMonotonic",
        )
    }

    fn get_userspace_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "UserspaceTimestamp",
        )
    }

    fn get_userspace_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "UserspaceTimestampMonotonic",
        )
    }

    fn get_finish_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "FinishTimestamp",
        )
    }

    fn get_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "FinishTimestampMonotonic",
        )
    }

    fn get_security_start_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "SecurityStartTimestamp",
        )
    }

    fn get_security_start_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "SecurityStartTimestampMonotonic",
        )
    }

    fn get_security_finish_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "SecurityFinishTimestamp",
        )
    }

    fn get_security_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "SecurityFinishTimestampMonotonic",
        )
    }

    fn get_generators_start_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "GeneratorsStartTimestamp",
        )
    }

    fn get_generators_start_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "GeneratorsStartTimestampMonotonic",
        )
    }

    fn get_generators_finish_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "GeneratorsFinishTimestamp",
        )
    }

    fn get_generators_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "GeneratorsFinishTimestampMonotonic",
        )
    }

    fn get_units_load_start_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "UnitsLoadStartTimestamp",
        )
    }

    fn get_units_load_start_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "UnitsLoadStartTimestampMonotonic",
        )
    }

    fn get_units_load_finish_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "UnitsLoadFinishTimestamp",
        )
    }

    fn get_units_load_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "UnitsLoadFinishTimestampMonotonic",
        )
    }

    fn get_init_rdsecurity_start_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDSecurityStartTimestamp",
        )
    }

    fn get_init_rdsecurity_start_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDSecurityStartTimestampMonotonic",
        )
    }

    fn get_init_rdsecurity_finish_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDSecurityFinishTimestamp",
        )
    }

    fn get_init_rdsecurity_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDSecurityFinishTimestampMonotonic",
        )
    }

    fn get_init_rdgenerators_start_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDGeneratorsStartTimestamp",
        )
    }

    fn get_init_rdgenerators_start_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDGeneratorsStartTimestampMonotonic",
        )
    }

    fn get_init_rdgenerators_finish_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDGeneratorsFinishTimestamp",
        )
    }

    fn get_init_rdgenerators_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDGeneratorsFinishTimestampMonotonic",
        )
    }

    fn get_init_rdunits_load_start_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDUnitsLoadStartTimestamp",
        )
    }

    fn get_init_rdunits_load_start_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDUnitsLoadStartTimestampMonotonic",
        )
    }

    fn get_init_rdunits_load_finish_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDUnitsLoadFinishTimestamp",
        )
    }

    fn get_init_rdunits_load_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "InitRDUnitsLoadFinishTimestampMonotonic",
        )
    }

    fn get_log_level(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "LogLevel",
        )
    }

    fn get_log_target(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "LogTarget",
        )
    }

    fn get_nnames(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "NNames",
        )
    }

    fn get_nfailed_units(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "NFailedUnits",
        )
    }

    fn get_njobs(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "NJobs",
        )
    }

    fn get_ninstalled_jobs(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "NInstalledJobs",
        )
    }

    fn get_nfailed_jobs(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "NFailedJobs",
        )
    }

    fn get_progress(&self) -> Result<f64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "Progress",
        )
    }

    fn get_environment(&self) -> Result<Vec<String>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "Environment",
        )
    }

    fn get_confirm_spawn(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "ConfirmSpawn",
        )
    }

    fn get_show_status(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "ShowStatus",
        )
    }

    fn get_unit_path(&self) -> Result<Vec<String>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "UnitPath",
        )
    }

    fn get_default_standard_output(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultStandardOutput",
        )
    }

    fn get_default_standard_error(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultStandardError",
        )
    }

    fn get_runtime_watchdog_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "RuntimeWatchdogUSec",
        )
    }

    fn get_reboot_watchdog_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "RebootWatchdogUSec",
        )
    }

    fn get_kexec_watchdog_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "KExecWatchdogUSec",
        )
    }

    fn get_service_watchdogs(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "ServiceWatchdogs",
        )
    }

    fn get_control_group(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "ControlGroup",
        )
    }

    fn get_system_state(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "SystemState",
        )
    }

    fn get_exit_code(&self) -> Result<u8, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "ExitCode",
        )
    }

    fn get_default_timer_accuracy_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultTimerAccuracyUSec",
        )
    }

    fn get_default_timeout_start_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultTimeoutStartUSec",
        )
    }

    fn get_default_timeout_stop_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultTimeoutStopUSec",
        )
    }

    fn get_default_timeout_abort_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultTimeoutAbortUSec",
        )
    }

    fn get_default_restart_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultRestartUSec",
        )
    }

    fn get_default_start_limit_interval_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultStartLimitIntervalUSec",
        )
    }

    fn get_default_start_limit_burst(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultStartLimitBurst",
        )
    }

    fn get_default_cpuaccounting(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultCPUAccounting",
        )
    }

    fn get_default_block_ioaccounting(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultBlockIOAccounting",
        )
    }

    fn get_default_memory_accounting(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultMemoryAccounting",
        )
    }

    fn get_default_tasks_accounting(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultTasksAccounting",
        )
    }

    fn get_default_limit_cpu(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitCPU",
        )
    }

    fn get_default_limit_cpusoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitCPUSoft",
        )
    }

    fn get_default_limit_fsize(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitFSIZE",
        )
    }

    fn get_default_limit_fsizesoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitFSIZESoft",
        )
    }

    fn get_default_limit_data(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitDATA",
        )
    }

    fn get_default_limit_datasoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitDATASoft",
        )
    }

    fn get_default_limit_stack(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitSTACK",
        )
    }

    fn get_default_limit_stacksoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitSTACKSoft",
        )
    }

    fn get_default_limit_core(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitCORE",
        )
    }

    fn get_default_limit_coresoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitCORESoft",
        )
    }

    fn get_default_limit_rss(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitRSS",
        )
    }

    fn get_default_limit_rsssoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitRSSSoft",
        )
    }

    fn get_default_limit_nofile(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitNOFILE",
        )
    }

    fn get_default_limit_nofilesoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitNOFILESoft",
        )
    }

    fn get_default_limit_as(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitAS",
        )
    }

    fn get_default_limit_assoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitASSoft",
        )
    }

    fn get_default_limit_nproc(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitNPROC",
        )
    }

    fn get_default_limit_nprocsoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitNPROCSoft",
        )
    }

    fn get_default_limit_memlock(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitMEMLOCK",
        )
    }

    fn get_default_limit_memlocksoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitMEMLOCKSoft",
        )
    }

    fn get_default_limit_locks(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitLOCKS",
        )
    }

    fn get_default_limit_lockssoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitLOCKSSoft",
        )
    }

    fn get_default_limit_sigpending(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitSIGPENDING",
        )
    }

    fn get_default_limit_sigpendingsoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitSIGPENDINGSoft",
        )
    }

    fn get_default_limit_msgqueue(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitMSGQUEUE",
        )
    }

    fn get_default_limit_msgqueuesoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitMSGQUEUESoft",
        )
    }

    fn get_default_limit_nice(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitNICE",
        )
    }

    fn get_default_limit_nicesoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitNICESoft",
        )
    }

    fn get_default_limit_rtprio(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitRTPRIO",
        )
    }

    fn get_default_limit_rtpriosoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitRTPRIOSoft",
        )
    }

    fn get_default_limit_rttime(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitRTTIME",
        )
    }

    fn get_default_limit_rttimesoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultLimitRTTIMESoft",
        )
    }

    fn get_default_tasks_max(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultTasksMax",
        )
    }

    fn get_timer_slack_nsec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "TimerSlackNSec",
        )
    }

    fn get_default_oompolicy(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.systemd1.Manager",
            "DefaultOOMPolicy",
        )
    }

    fn set_log_level(&self, value: String) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "org.freedesktop.systemd1.Manager",
            "LogLevel",
            value,
        )
    }

    fn set_log_target(&self, value: String) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "org.freedesktop.systemd1.Manager",
            "LogTarget",
            value,
        )
    }

    fn set_runtime_watchdog_usec(&self, value: u64) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "org.freedesktop.systemd1.Manager",
            "RuntimeWatchdogUSec",
            value,
        )
    }

    fn set_reboot_watchdog_usec(&self, value: u64) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "org.freedesktop.systemd1.Manager",
            "RebootWatchdogUSec",
            value,
        )
    }

    fn set_kexec_watchdog_usec(&self, value: u64) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "org.freedesktop.systemd1.Manager",
            "KExecWatchdogUSec",
            value,
        )
    }

    fn set_service_watchdogs(&self, value: bool) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "org.freedesktop.systemd1.Manager",
            "ServiceWatchdogs",
            value,
        )
    }
}

pub fn org_freedesktop_systemd1_manager_server<F, T, D>(
    factory: &tree::Factory<tree::MTFn<D>, D>,
    data: D::Interface,
    f: F,
) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    D::Signal: Default,
    T: OrgFreedesktopSystemd1Manager<Err = tree::MethodErr>,
    F: 'static + for<'z> Fn(&'z tree::MethodInfo<tree::MTFn<D>, D>) -> &'z T,
{
    let i = factory.interface("org.freedesktop.systemd1.Manager", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_by_pid(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitByPID", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<u8> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_by_invocation_id(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitByInvocationID", Default::default(), h);
    let m = m.in_arg(("", "ay"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_by_control_group(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitByControlGroup", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.load_unit(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("LoadUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.start_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("StartUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.start_unit_replace(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("StartUnitReplace", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.stop_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("StopUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.reload_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ReloadUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.restart_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("RestartUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.try_restart_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("TryRestartUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.reload_or_restart_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ReloadOrRestartUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.reload_or_try_restart_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ReloadOrTryRestartUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: &str = i.read()?;
        let d = fclone(minfo);
        let (arg0, arg1, arg2, arg3, arg4, arg5) = d.enqueue_unit_job(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(arg1);
        let rm = rm.append1(arg2);
        let rm = rm.append1(arg3);
        let rm = rm.append1(arg4);
        let rm = rm.append1(arg5);
        Ok(vec![rm])
    };
    let m = factory.method("EnqueueUnitJob", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "u"));
    let m = m.out_arg(("", "o"));
    let m = m.out_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let m = m.out_arg(("", "s"));
    let m = m.out_arg(("", "a(uosos)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: i32 = i.read()?;
        let d = fclone(minfo);
        d.kill_unit(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("KillUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.clean_unit(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("CleanUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.reset_failed_unit(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("ResetFailedUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)> = i.read()?;
        let d = fclone(minfo);
        d.set_unit_properties(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("SetUnitProperties", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "a(sv)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.ref_unit(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("RefUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.unref_unit(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("UnrefUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)> = i.read()?;
        let arg3: Vec<(&str, Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>)> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.start_transient_unit(arg0, arg1, arg2, arg3)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("StartTransientUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "a(sv)"));
    let m = m.in_arg(("", "a(sa(sv))"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_processes(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitProcesses", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "a(sus)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: Vec<u32> = i.read()?;
        let d = fclone(minfo);
        d.attach_processes_to_unit(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("AttachProcessesToUnit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "au"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.abandon_scope(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("AbandonScope", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_job(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetJob", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_job_after(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetJobAfter", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "a(usssoo)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_job_before(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetJobBefore", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "a(usssoo)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        d.cancel_job(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("CancelJob", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.clear_jobs()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("ClearJobs", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reset_failed()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("ResetFailed", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.list_units()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnits", Default::default(), h);
    let m = m.out_arg(("", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.list_units_filtered(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnitsFiltered", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.out_arg(("", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.list_units_by_patterns(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnitsByPatterns", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "as"));
    let m = m.out_arg(("", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.list_units_by_names(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnitsByNames", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.out_arg(("", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.list_jobs()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListJobs", Default::default(), h);
    let m = m.out_arg(("", "a(usssoo)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.subscribe()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Subscribe", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.unsubscribe()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Unsubscribe", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.dump()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("Dump", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.dump_by_file_descriptor()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("DumpByFileDescriptor", Default::default(), h);
    let m = m.out_arg(("", "h"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reload()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Reload", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reexecute()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Reexecute", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.exit()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Exit", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reboot()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Reboot", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.power_off()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("PowerOff", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.halt()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("Halt", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.kexec()?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("KExec", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        d.switch_root(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("SwitchRoot", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.set_environment(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("SetEnvironment", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.unset_environment(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("UnsetEnvironment", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.unset_and_set_environment(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("UnsetAndSetEnvironment", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.list_unit_files()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnitFiles", Default::default(), h);
    let m = m.out_arg(("", "a(ss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.list_unit_files_by_patterns(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("ListUnitFilesByPatterns", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "as"));
    let m = m.out_arg(("", "a(ss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_file_state(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitFileState", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let (arg0, arg1) = d.enable_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(arg1);
        Ok(vec![rm])
    };
    let m = factory.method("EnableUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.disable_unit_files(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("DisableUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let (arg0, arg1) = d.reenable_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(arg1);
        Ok(vec![rm])
    };
    let m = factory.method("ReenableUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.link_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("LinkUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let (arg0, arg1) = d.preset_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(arg1);
        Ok(vec![rm])
    };
    let m = factory.method("PresetUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: bool = i.read()?;
        let arg3: bool = i.read()?;
        let d = fclone(minfo);
        let (arg0, arg1) = d.preset_unit_files_with_mode(arg0, arg1, arg2, arg3)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(arg1);
        Ok(vec![rm])
    };
    let m = factory.method("PresetUnitFilesWithMode", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.mask_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("MaskUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.unmask_unit_files(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("UnmaskUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.revert_unit_files(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("RevertUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.set_default_target(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("SetDefaultTarget", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_default_target()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetDefaultTarget", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.preset_all_unit_files(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("PresetAllUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: Vec<&str> = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: &str = i.read()?;
        let arg3: bool = i.read()?;
        let arg4: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.add_dependency_unit_files(arg0, arg1, arg2, arg3, arg4)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("AddDependencyUnitFiles", Default::default(), h);
    let m = m.in_arg(("", "as"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: bool = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_unit_file_links(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetUnitFileLinks", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.out_arg(("", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u8 = i.read()?;
        let d = fclone(minfo);
        d.set_exit_code(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec![rm])
    };
    let m = factory.method("SetExitCode", Default::default(), h);
    let m = m.in_arg(("", "y"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.lookup_dynamic_user_by_name(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("LookupDynamicUserByName", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.lookup_dynamic_user_by_uid(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("LookupDynamicUserByUID", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.get_dynamic_users()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec![rm])
    };
    let m = factory.method("GetDynamicUsers", Default::default(), h);
    let m = m.out_arg(("", "a(us)"));
    let i = i.add_m(m);

    let p = factory.property::<&str, _>("Version", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_version()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Features", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_features()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Virtualization", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_virtualization()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Architecture", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_architecture()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Tainted", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_tainted()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FirmwareTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_firmware_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FirmwareTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_firmware_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("LoaderTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_loader_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("LoaderTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_loader_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("KernelTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_kernel_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("KernelTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_kernel_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdtimestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdtimestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UserspaceTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_userspace_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UserspaceTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_userspace_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_security_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_security_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_security_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_security_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_generators_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_generators_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_generators_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_generators_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_units_load_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_units_load_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_units_load_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_units_load_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDSecurityStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdsecurity_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDSecurityStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdsecurity_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDSecurityFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdsecurity_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p =
        factory.property::<u64, _>("InitRDSecurityFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdsecurity_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDGeneratorsStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdgenerators_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>(
        "InitRDGeneratorsStartTimestampMonotonic",
        Default::default(),
    );
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdgenerators_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDGeneratorsFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdgenerators_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>(
        "InitRDGeneratorsFinishTimestampMonotonic",
        Default::default(),
    );
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdgenerators_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDUnitsLoadStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdunits_load_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p =
        factory.property::<u64, _>("InitRDUnitsLoadStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdunits_load_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDUnitsLoadFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdunits_load_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>(
        "InitRDUnitsLoadFinishTimestampMonotonic",
        Default::default(),
    );
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_init_rdunits_load_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("LogLevel", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_log_level()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_log_level(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("LogTarget", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_log_target()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_log_target(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NNames", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_nnames()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NFailedUnits", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_nfailed_units()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NJobs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_njobs()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NInstalledJobs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_ninstalled_jobs()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NFailedJobs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_nfailed_jobs()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<f64, _>("Progress", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_progress()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("Environment", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_environment()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ConfirmSpawn", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_confirm_spawn()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ShowStatus", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_show_status()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("UnitPath", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_unit_path()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("DefaultStandardOutput", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_standard_output()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("DefaultStandardError", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_standard_error()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("RuntimeWatchdogUSec", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_runtime_watchdog_usec()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_runtime_watchdog_usec(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("RebootWatchdogUSec", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_reboot_watchdog_usec()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_reboot_watchdog_usec(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("KExecWatchdogUSec", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_kexec_watchdog_usec()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_kexec_watchdog_usec(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ServiceWatchdogs", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_service_watchdogs()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_service_watchdogs(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("ControlGroup", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_control_group()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("SystemState", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_system_state()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u8, _>("ExitCode", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_exit_code()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimerAccuracyUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_timer_accuracy_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimeoutStartUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_timeout_start_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimeoutStopUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_timeout_stop_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimeoutAbortUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_timeout_abort_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultRestartUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_restart_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultStartLimitIntervalUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_start_limit_interval_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("DefaultStartLimitBurst", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_start_limit_burst()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultCPUAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_cpuaccounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultBlockIOAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_block_ioaccounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultMemoryAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_memory_accounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultTasksAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_tasks_accounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCPU", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_cpu()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCPUSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_cpusoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitFSIZE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_fsize()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitFSIZESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_fsizesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitDATA", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_data()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitDATASoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_datasoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSTACK", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_stack()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSTACKSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_stacksoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCORE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_core()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCORESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_coresoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRSS", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rss()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRSSSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rsssoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNOFILE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nofile()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNOFILESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nofilesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitAS", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_as()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitASSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_assoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNPROC", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nproc()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNPROCSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nprocsoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMEMLOCK", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_memlock()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMEMLOCKSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_memlocksoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitLOCKS", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_locks()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitLOCKSSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_lockssoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSIGPENDING", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_sigpending()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSIGPENDINGSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_sigpendingsoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMSGQUEUE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_msgqueue()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMSGQUEUESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_msgqueuesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNICE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nice()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNICESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_nicesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTPRIO", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rtprio()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTPRIOSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rtpriosoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTTIME", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rttime()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTTIMESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_limit_rttimesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTasksMax", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_tasks_max()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("TimerSlackNSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_timer_slack_nsec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("DefaultOOMPolicy", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_default_oompolicy()?);
        Ok(())
    });
    let i = i.add_p(p);
    let s = factory.signal("UnitNew", Default::default());
    let s = s.arg(("", "s"));
    let s = s.arg(("", "o"));
    let i = i.add_s(s);
    let s = factory.signal("UnitRemoved", Default::default());
    let s = s.arg(("", "s"));
    let s = s.arg(("", "o"));
    let i = i.add_s(s);
    let s = factory.signal("JobNew", Default::default());
    let s = s.arg(("", "u"));
    let s = s.arg(("", "o"));
    let s = s.arg(("", "s"));
    let i = i.add_s(s);
    let s = factory.signal("JobRemoved", Default::default());
    let s = s.arg(("", "u"));
    let s = s.arg(("", "o"));
    let s = s.arg(("", "s"));
    let s = s.arg(("", "s"));
    let i = i.add_s(s);
    let s = factory.signal("StartupFinished", Default::default());
    let s = s.arg(("", "t"));
    let s = s.arg(("", "t"));
    let s = s.arg(("", "t"));
    let s = s.arg(("", "t"));
    let s = s.arg(("", "t"));
    let s = s.arg(("", "t"));
    let i = i.add_s(s);
    let s = factory.signal("UnitFilesChanged", Default::default());
    let i = i.add_s(s);
    let s = factory.signal("Reloading", Default::default());
    let s = s.arg(("", "b"));
    let i = i.add_s(s);
    i
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerUnitNew {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerUnitNew {
    const NAME: &'static str = "UnitNew";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerUnitRemoved {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerUnitRemoved {
    const NAME: &'static str = "UnitRemoved";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerJobNew {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
    pub arg2: String,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerJobNew {
    const NAME: &'static str = "JobNew";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
        arg::RefArg::append(&self.arg2, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        self.arg2 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerJobRemoved {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
    pub arg2: String,
    pub arg3: String,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerJobRemoved {
    const NAME: &'static str = "JobRemoved";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
        arg::RefArg::append(&self.arg2, i);
        arg::RefArg::append(&self.arg3, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        self.arg2 = i.read()?;
        self.arg3 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerStartupFinished {
    pub arg0: u64,
    pub arg1: u64,
    pub arg2: u64,
    pub arg3: u64,
    pub arg4: u64,
    pub arg5: u64,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerStartupFinished {
    const NAME: &'static str = "StartupFinished";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
        arg::RefArg::append(&self.arg2, i);
        arg::RefArg::append(&self.arg3, i);
        arg::RefArg::append(&self.arg4, i);
        arg::RefArg::append(&self.arg5, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        self.arg2 = i.read()?;
        self.arg3 = i.read()?;
        self.arg4 = i.read()?;
        self.arg5 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerUnitFilesChanged {}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerUnitFilesChanged {
    const NAME: &'static str = "UnitFilesChanged";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, _: &mut arg::IterAppend) {}
    fn get(&mut self, _: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerReloading {
    pub arg0: bool,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerReloading {
    const NAME: &'static str = "Reloading";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        Ok(())
    }
}
